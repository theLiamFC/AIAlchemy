
{
    "pin":"from machine import Pin\ndigital_out = Pin(12, Pin.OUT)\ndigital_in = Pin(11, Pin.IN)\nsignal = digital_in.value()\ndigital_out.on()\ndigital_out.off()",
    "bluetooth":"import bluetooth\nimport time\nimport struct\n\nNAME_FLAG = 0x09\nSCAN_RESULT = 5\nSCAN_DONE = 6\nNAME_FLAG = 0x09\nADV_TYPE_UUID128_COMPLETE = 0x07\nIRQ_CENTRAL_CONNECT = 1\nIRQ_CENTRAL_DISCONNECT = 2\nIRQ_GATTS_WRITE = 3\n\nUART_SERVICE_UUID = bluetooth.UUID(\"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\")\nUART_RX_CHAR_UUID = bluetooth.UUID(\"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\")\nUART_TX_CHAR_UUID = bluetooth.UUID(\"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\")\n\nFLAG_READ = 0x0002\nFLAG_WRITE_NO_RESPONSE = 0x0004\nFLAG_WRITE = 0x0008\nFLAG_NOTIFY = 0x0010\n\nUART_UUID = UART_SERVICE_UUID\nUART_TX = (UART_TX_CHAR_UUID, FLAG_READ | FLAG_NOTIFY,)\nUART_RX = (UART_RX_CHAR_UUID, FLAG_WRITE | FLAG_WRITE_NO_RESPONSE,)\nUART_SERVICE = (UART_UUID, (UART_TX, UART_RX),)\n\nclass Yell: # peripheral\n    def __init__(self):\n        self._ble = bluetooth.BLE()\n        self._ble.active(True)\n        ((self._handle_tx, self._handle_rx),) = self._ble.gatts_register_services((UART_SERVICE,))\n        print('setup as uart')\n        self._connections = set()\n        self._write_callback = None\n        self._ble.irq(self._irq)\n        self._write_callback = self.on_rx\n\n    def advertise(self, name = 'Pico', interval_us=100000):\n        short = name[:8]\npayload = struct.pack(\"BB\", len(short) + 1, NAME_FLAG) + short\n        self._ble.gap_advertise(interval_us, adv_data=payload)\n\n    def stop_advertising(self):\n        self._ble.gap_advertise(None)\n\n    def _irq(self, event, data):\n        if event == IRQ_CENTRAL_CONNECT:\n            conn_handle, _, _ = data\n            print(\"New connection\", conn_handle)\n            self._connections.add(conn_handle)\n            self.stop_advertising()\n        elif event == IRQ_CENTRAL_DISCONNECT:\n            conn_handle, _, _ = data\n            print(\"Disconnected\", conn_handle)\n            self._connections.remove(conn_handle)\n            self._write_callback = None\n        elif event == IRQ_GATTS_WRITE:\n            conn_handle, value_handle = data\n            value = self._ble.gatts_read(value_handle)\n            if value_handle == self._handle_rx and self._write_callback:\n                self._write_callback(value)\n\n    def on_rx(self, v):\n        print(\"received\", v)\n        self.send(v)\n\n    def send(self, data):\n        for conn_handle in self._connections:\n            self._ble.gatts_notify(conn_handle, self._handle_tx, data)\n\n    def is_connected(self):\n        return len(self._connections) > 0\n\n    def disconnect(self):\n        for conn_handle in self._connections:\n            self._ble.gap_disconnect(conn_handle)\np = Yell()\np.advertise('Fred')\n\nwhile not p.is_connected():\n    time.sleep(0.5)\np.stop_advertising()\ntime.sleep(2)\nfor i in range(10):\n    p.send(str(i) + chr(i))\ntime.sleep(1)\np.disconnect()",
    "led":"from machine import Pin\nled = Pin(25, Pin.OUT)\nled.toggle()"
}
